:_mod-docs-content-type: REFERENCE

[id="ref-best-practices-for-localization_{context}"]
= Best practices for implementing localization support for custom plugins in {product-very-short}
When you add localization support to your {product-very-short} plugins the following best practices help ensure that you establish a robust, type-safe, and future-proof localization workflow, separating the immutable source text from the organized key structure and ensuring reliable deployment across all targeted languages:

Do not modify original English strings:: This preserves the source of truth for all translators, preventing unexpected changes that would invalidate existing translations and ensuring consistency across all versions.

Use flat dot notation in translation files:: Flat dot notation, for example `page.title`, follows the standard `i18next` library convention, which optimizes runtime lookups and keeps the actual translation values concise and easy to manage for translation services.

Use nested objects in the reference file for TypeScript support:: This allows the TypeScript compiler to enforce structural type checking on your translation keys, catching errors during development rather than at runtime.

Test with mocks to ensure translations work correctly:: This isolates the translation logic, guaranteeing the correct keys are passed and rendered without relying on a full environment setup or external translation files during unit testing.

Add all languages to your application configuration:: This ensures that the {product-very-short} application initializes and loads all necessary language resources at startup, making the locales immediately available for users to select in the UI.

.Common patterns

[cols="20%,35%,45%", frame="all", options="header"]
|===
| Use case | Pattern | Example

| Simple text	
| `t('key')` 
| `t('page.title')`

| With variables
| `t('key', {param})`	
| `t('table.topN', {count: '5'})`

| Dynamic keys
| `t(config.titleKey as any)`	
| `t('cards.overview.title' as any)`
|===