:_mod-docs-content-type: CONCEPT

[id="con-plan-your-deployment-with-system-architecture_{context}"]
= Plan your deployment with system architecture

{product} ({product-very-short}) uses a client-server architecture consisting of a browser-based frontend, and a stateless backend service layer. Understanding this architecture allows platform engineers to plan for horizontal scaling, high availability, and efficient data synchronization across the Software Catalog.

By understanding the {product-very-short} architecture, you can perform the following planning tasks:

Plan scalable deployments:: Deploy multiple backend instances behind a load balancer to handle increased load.
Ensure high availability:: Configure database replication and cache clustering to prevent single points of failure.
Optimize resource allocation:: Right-size your infrastructure by understanding which components require persistent storage versus high-performance memory.

The following diagram shows the {product-very-short} internal architecture (frontend and backend) and its external dependencies, such as authentication providers, load balancers, and databases:

image::rhdh/rhdh-architecture-diagram.png[]

The {product-very-short} architecture consists of three primary layers. While the data layer (PostgreSQL and optional Redis cache) provides storage for the indexed Software Catalog, the source of truth resides in external integrations, such as Git repositories, CI/CD platforms, and other integrations. Catalog providers continuously scan these external systems and synchronize data to the database for fast querying.

.Frontend (Client)
The frontend is a single-page application (SPA) that runs in your web browser. It provides you with the interface for browsing the Software Catalog, interfacing with plugins, and connecting to external integrations. The frontend communicates with the backend exclusively through REST API calls.

.Backend (Service Layer)
The backend provides REST API endpoints that the frontend consumes. It manages the Software Catalog (an inventory of your organization's software components, APIs, and resources) and handles your authentication.

Because of this stateless design, you can scale the backend horizontally by running multiple instances behind a load balancer; any instance can serve any incoming request. All persistent state is externalized to a PostgreSQL database, including:

* Catalog entities
* Task history
* Session data (through a database-backed session store)

.External data dependencies
{product-very-short} requires PostgreSQL for persistence. While a logical cache is optional, it is recommended for production environments.

PostgreSQL database::
    Stores indexed Software Catalog entities (synchronized from external systems like Git repositories and CI/CD platforms), profiles, authentication data, and backend state. You must configure PostgreSQL with high availability (HA) for production deployments.

Redis Cache (Optional)::
    You can configure Redis as a shared logical cache across backend instances. This improves performance by caching frequently accessed data, such as rendered TechDocs and catalog entities.

[TIP]
====
While the default in-memory cache is suitable for single-instance deployments, use Redis for production deployments with multiple backend instances to ensure cache consistency.
====