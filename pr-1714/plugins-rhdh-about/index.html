<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="chrometwo"><head><title>Develop and deploy dynamic plugins in Red Hat Developer Hub</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css"/><meta name="generator" content="publican v4.3.2"/><meta name="description" content="The Red Hat Developer Hub (RHDH) application offers a unified platform with various plugins. Using the plugin ecosystem within the Developer Hub application, you can access your development infrastructure and software development tools."/><link rel="next" href="#assembly-developing-and-deploying-plugins" title="1. Developing and deploying dynamic plugins in Red Hat Developer Hub"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><script type="text/javascript" src="Common_Content/scripts/jquery-1.7.1.min.js"> </script><script type="text/javascript" src="Common_Content/scripts/utils.js"> </script><script type="text/javascript" src="Common_Content/scripts/highlight.js/highlight.pack.js"> </script></head><body><div id="chrometwo"><div id="main"><section xml:lang="en-US" class="article" id="idm46550816463088"><div class="titlepage"><div><div class="producttitle"><span class="productname">Red Hat Developer Hub</span> <span class="productnumber">1.9</span></div><div><h1 class="title">Develop and deploy dynamic plugins in Red Hat Developer Hub</h1></div><div><h3 class="subtitle"><em>RHDH dynamic plugins: From development to deployment </em></h3></div><div><div xml:lang="en-US" class="authorgroup"><span class="orgname">Red Hat Customer Content Services</span></div></div><div><a href="#idm46550792890128">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
				The Red Hat Developer Hub (RHDH) application offers a unified platform with various plugins. Using the plugin ecosystem within the Developer Hub application, you can access your development infrastructure and software development tools.
			</div></div></div></div><hr/></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#assembly-developing-and-deploying-plugins">1. Developing and deploying dynamic plugins in Red Hat Developer Hub</a></span><ul><li><span class="section"><a href="#con-understand-dynamic-plugins-in-red-hat-developer-hub_assembly-developing-and-deploying-plugins">1.1. Overview of dynamic plugins</a></span></li><li><span class="section"><a href="#con-setting-up-the-development-toolchain_assembly-developing-and-deploying-plugins">1.2. Prepare your development environment</a></span></li><li><span class="section"><a href="#proc-developing-plugins-from-scratch_assembly-developing-and-deploying-plugins">1.3. Developing a new plugin</a></span></li><li><span class="section"><a href="#proc-converting-a-custom-plugin-into-an-rhdh-dynamic-plugin_assembly-developing-and-deploying-plugins">1.4. Converting a custom plugin into a dynamic plugin</a></span></li><li><span class="section"><a href="#convert-a-custom-plugin-to-a-dynamic-plugin-by-using-the-plugin-factory">1.5. Convert a custom plugin to a dynamic plugin by using the Plugin Factory</a></span></li><li><span class="section"><a href="#con-testing-with-rhdh-local_assembly-developing-and-deploying-plugins">1.6. Verify plugins locally</a></span></li><li><span class="section"><a href="#proc-packaging-and-publishing-artifacts_assembly-developing-and-deploying-plugins">1.7. Packaging and publishing artifacts</a></span></li><li><span class="section"><a href="#proc-deployment-configurations_assembly-developing-and-deploying-plugins">1.8. Deployment configurations</a></span></li><li><span class="section"><a href="#ref-best-practices-and-reference_assembly-developing-and-deploying-plugins">1.9. Maintain and scale plugins to ensure long-term stability</a></span></li></ul></li></ul></div><section class="section" id="assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h2 class="title">1. Developing and deploying dynamic plugins in Red Hat Developer Hub</h2></div></div></div><section class="section" id="con-understand-dynamic-plugins-in-red-hat-developer-hub_assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h3 class="title">1.1. Overview of dynamic plugins</h3></div></div></div><section class="section" id="con-converting-custom-plugins"><div class="titlepage"><div><div><h4 class="title">1.1.1. Dynamic Plugins</h4></div></div></div><p>
					Red Hat Developer Hub implements a dynamic plugin system. You can install, configure, and load plugins at runtime without changing or rebuilding the application. You only need a restart. You can load these plugins from NPM, tarballs, or OCI compliant container images.
				</p><p>
					With dynamic plugins, instead of modifying the Backstage application itself, you create a <code class="literal">dynamic-plugins.yaml</code> file to specify the plugins that Red Hat Developer Hub will install and enable at startup. For example, the following configuration loads a plugin named <code class="literal">plugin-name</code>, which is stored in a <code class="literal">Quay.io</code> container image at <code class="literal">quay.io/account-name/image-name</code>:
				</p><div class="formalpara"><p class="title"><strong><code class="literal">dynamic-plugins.yaml</code> fragment</strong></p><p>
						
<pre class="programlisting language-yaml">plugins:
  - package: oci://quay.io/account-name/image-name:tag!plugin-name
    disabled: false
    pluginConfig: {}</pre>
					</p></div></section></section><section class="section" id="con-setting-up-the-development-toolchain_assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h3 class="title">1.2. Prepare your development environment</h3></div></div></div><p>
				Before creating or converting plugins for Red Hat Developer Hub (RHDH), you must establish a specific local development toolchain. This toolchain allows you to write standard Backstage code, convert it into a dynamic format, and package it for deployment without rebuilding the core RHDH platform.
			</p><section class="section" id="required-skills-and-languages"><div class="titlepage"><div><div><h4 class="title">1.2.1. Required skills and languages</h4></div></div></div><p>
					To develop dynamic plugins, you should possess the following technical proficiencies:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">JavaScript and TypeScript</span></dt><dd>
								The core languages used for Backstage frontend and backend development.
							</dd><dt><span class="term">React</span></dt><dd>
								Required for building frontend plugin components.
							</dd><dt><span class="term">Node.js ecosystem</span></dt><dd>
								Familiarity with package management (NPM/Yarn) and module handling.
							</dd></dl></div></section><section class="section" id="the-development-toolchain"><div class="titlepage"><div><div><h4 class="title">1.2.2. The development toolchain</h4></div></div></div><p>
					The following tools are essential for initializing, building, and packaging your plugins:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Node.js (via NVM)</span></dt><dd><p class="simpara">
								Node.js is the engine that runs JavaScript on your computer.
							</p><p class="simpara">
								Backstage requires specific Active LTS (Long Term Support) versions (v18 or v20) to function correctly. Using Node Version Manager (NVM) allows you to switch between these versions easily, ensuring compatibility with the RHDH backend system.
							</p></dd><dt><span class="term">Yarn (Classic)</span></dt><dd><p class="simpara">
								Yarn is a package manager that handles all the libraries (dependencies) that your application needs.
							</p><p class="simpara">
								The Backstage project structure is optimized for Yarn (specifically Yarn Classic 1.x) to manage workspaces and dependencies efficiently.
							</p></dd><dt><span class="term">Containerization tools (Docker or Podman)</span></dt><dd><p class="simpara">
								These tools used to run containers and package applications.
							</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										Packaging: Dynamic plugins are recommended to be distributed as OCI images. You use Docker or Podman to package your derived plugin assets into an image that can be pushed to a registry, for example, Quay.io and sideloaded into RHDH.
									</li><li class="listitem">
										TechDocs: Docker is used locally to run containers that generate technical documentation.
									</li></ul></div></dd><dt><span class="term">RHDH plugin tools</span></dt><dd><p class="simpara">
								These specialized tools facilitate the conversion of standard plugins into the dynamic architecture required by RHDH.
							</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										RHDH Plugin Factory and RHDH-cli: These tools assist in initializing new plugins or converting existing standard Backstage plugins into the RHDH dynamic plugin format. They help structure the code to support dynamic loading.
									</li><li class="listitem">
										Janus IDP CLI (@janus-idp/cli): This command-line tool is critical for the export process. It allows you to run commands like export-dynamic-plugin, which repackages your code into a derived package containing the necessary configuration (like Scalprum for frontend) and dependency handling (bundling private dependencies vs. sharing platform dependencies)
									</li></ul></div></dd></dl></div></section></section><section class="section" id="proc-developing-plugins-from-scratch_assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h3 class="title">1.3. Developing a new plugin</h3></div></div></div><section class="section" id="creating-a-new-backstage-application"><div class="titlepage"><div><div><h4 class="title">1.3.1. Creating a new Backstage application</h4></div></div></div><p>
					To develop your own Backstage plugin, your must first create a standalone Backstage installation in your local environment.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						This is not a production-ready installation, and it does not contain information specific to your organization until you set up integrations with your specific data sources.
					</p></div></div><p>
					General folder structure Below is a simplified layout of the files and folders generated when creating an app.
				</p><pre class="programlisting language-terminal">app
├── app-config.yaml
├── catalog-info.yaml
├── package.json
└── packages
    ├── app
    └── backend</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">app-config.yaml</span></dt><dd>
								Main configuration file for the app. See Configuration for more information.
							</dd><dt><span class="term">catalog-info.yaml</span></dt><dd>
								Catalog Entities descriptors. See Descriptor Format of Catalog Entities to get started.
							</dd><dt><span class="term">package.json</span></dt><dd>
								Root package.json for the project. Note: Be sure that you don’t add any npm dependencies here as they probably should be installed in the intended workspace rather than in the root.
							</dd><dt><span class="term">packages/</span></dt><dd>
								Yarn workspaces, everything here is going to be a separate package, managed by Yarn.
							</dd><dt><span class="term">packages/app/</span></dt><dd>
								A fully functioning Backstage frontend app that acts as a good starting point for you to get to know Backstage.
							</dd><dt><span class="term">packages/backend/</span></dt><dd>
								We include a backend that helps power features such as Authentication, Software Catalog, Software Templates and TechDocs amongst other things.
							</dd></dl></div><div class="formalpara"><p class="title"><strong>Prerequisites</strong></p><p>
						This guide also assumes a basic understanding of working on a Linux based operating system and have some experience with the terminal, specifically, these commands: npm, yarn.
					</p></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							A minimum of 20 GB disk space to run the standalone Backstage application with demo data. NOTE: As you add more modules and plugins to an installation, the disk space requirements will increase, accordingly.
						</li><li class="listitem">
							A minimum of 6 GB memory. Access to a Unix-based operating system, such as Linux, macOS or Windows Subsystem for Linux. The Linux version must support the required Node.js version.
						</li><li class="listitem">
							A GNU-like build environment available at the command line. For example, on Debian/Ubuntu you will want to have the make and build-essential packages installed. On macOS, you will want to run xcode-select --install to get the XCode command line build tooling in place.
						</li><li class="listitem">
							An account with elevated rights to install the dependencies
						</li><li class="listitem">
							curl or wget installed
						</li><li class="listitem"><p class="simpara">
							Node.js Active LTS Release installed using one of these methods:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
									Using nvm (recommended)
								</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
											Installing nvm
										</li><li class="listitem">
											Install and change Node version with nvm
										</li><li class="listitem">
											Node 24 is a good starting point, this can be installed using nvm install lts/krypton
										</li></ul></div></li><li class="listitem">
									Binary Download
								</li><li class="listitem">
									Package manager
								</li><li class="listitem">
									Using NodeSource packages
								</li></ul></div></li><li class="listitem">
							Install the isolated-vm module, following their requirements section.
						</li><li class="listitem"><p class="simpara">
							yarn Installation
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
									Backstage currently uses Yarn 4.4.1, once you’ve ran corepack enable you’ll want to then run yarn set version 4.4.1
								</li></ul></div></li><li class="listitem">
							docker installation
						</li><li class="listitem">
							git installation
						</li><li class="listitem">
							If the system is not directly accessible over your network the following ports need to be opened: 3000, 7007. This is quite uncommon, unless you’re installing in a container, VM or remote system.
						</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Create a Backstage application, as follows:
						</p><pre class="programlisting language-terminal">npx @backstage/create-app@latest</pre></li><li class="listitem"><p class="simpara">
							If this is the first time that you are installing a Backstage application on this device, the following question is displayed. Enter y and select Enter to proceed with the installation.
						</p><pre class="screen">     Need to install the following packages:
     @backstage/create-app@0.7.4
     ok to proceed? (y)</pre></li><li class="listitem">
							Enter the name for your application and select Enter. This is the root directory of your application. In this example, the name is set to my-backstage-app.
						</li></ol></div><div class="formalpara"><p class="title"><strong>Output from create app</strong></p><p>
						<span class="emphasis"><em>To be added</em></span>
					</p></div><p>
					Your Backstage app is fully installed and ready to be run! Now that the installation is complete, you can go to the application directory and start the app using the yarn start command. The yarn start command will run both the frontend and backend as separate processes (named [0] and [1]) in the same window.
				</p><div class="orderedlist"><p class="title"><strong>Verification</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Change to the root directory of your Backstage app. This is the same as the name of your application that you provided during the installation. In this example, it is my-backstage-app.
						</p><pre class="programlisting language-terminal">cd my-backstage-app</pre></li><li class="listitem"><p class="simpara">
							Start the Backstage application.
						</p><pre class="programlisting language-terminal">yarn start</pre><p class="simpara">
							As the frontend and backend are starting, you will see output similar to the following. The output shows that the app and backend are starting up with the configuration coming from app-config.yaml. You will see the plugins being initialized, and authorization and permissions being setup. In addition you will see a series of REST API calls for those plugins that use a service backend, such as the service catalog.
						</p></li></ol></div><div class="formalpara"><p class="title"><strong>Output from starting the application</strong></p><p>
						
<pre class="programlisting language-terminal">Starting app, backend
Loaded config from app-config.yaml
.
.
2025-10-15T12:26:41.564Z backstage info Plugin initialization started: 'app', 'proxy', 'scaffolder', 'techdocs', 'auth', 'catalog', 'permission', 'search', 'kubernetes', 'notifications', 'signals' type="initialization"
Rspack compiled successfully
.
.
2025-10-15T15:17:21.130Z auth info Created new signing key eec1a9e4-4395-4698-9a9f-f1b5cbcf152b component="token-factory"
2025-10-15T15:17:21.139Z auth info Issuing token for user:development/guest, with entities user:development/guest component="token-factory"
2025-10-15T15:17:21.223Z rootHttpRouter info [2025-10-15T15:17:21.223Z] "GET /api/auth/guest/refresh HTTP/1.1" 200 802 "http://localhost:3000/" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:143.0) Gecko/20100101 Firefox/143.0" type="incomingRequest" date="2025-10-15T15:17:21.223Z" method="GET" url="/api/auth/guest/refresh" status=200 httpVersion="1.1" userAgent="Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:143.0) Gecko/20100101 Firefox/143.0" contentLength=802 referrer="http://localhost:3000/"
.
.
2025-10-15T15:17:24.051Z rootHttpRouter info [2025-10-15T15:17:24.051Z] "GET /api/catalog/entities?fields=metadata,kind,spec.profile&amp;filter=kind%3Dgroup%2Crelations.hasMember%3Duser%3Adevelopment%2Fguest HTTP/1.1" 304 0 "http://localhost:3000/" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:143.0) Gecko/20100101 Firefox/143.0" type="incomingRequest" date="2025-10-15T15:17:24.051Z" method="GET" url="/api/catalog/entities?fields=metadata,kind,spec.profile&amp;filter=kind%3Dgroup%2Crelations.hasMember%3Duser%3Adevelopment%2Fguest" status=304 httpVersion="1.1" userAgent="Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:143.0) Gecko/20100101 Firefox/143.0" referrer="http://localhost:3000/"
.
.</pre>
					</p></div><p>
					Once the Backstage UI is displayed, you can start exploring the demo immediately.
				</p></section><section class="section" id="creating-a-new-plugin"><div class="titlepage"><div><div><h4 class="title">1.3.2. Creating a new plugin</h4></div></div></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Run <code class="literal">yarn install</code> to install dependencies.
						</li><li class="listitem"><p class="simpara">
							Create a new plugin by using the <code class="literal">yarn new</code> command, as follows:
						</p><pre class="programlisting language-terminal">yarn new</pre></li><li class="listitem">
							Select the type of plugin to create, for example, <code class="literal">frontend-plugin</code>.
						</li><li class="listitem">
							Enter the ID of the plugin, for example, <code class="literal">my-plugin</code>.
						</li></ol></div><p>
					This will create a new Backstage Plugin based on the ID that was provided. It will be built and added to the Backstage App automatically.
				</p><div class="formalpara"><p class="title"><strong>Verify</strong></p><p>
						If the Backstage App is already running (with yarn start) you should be able to see the default page for your new plugin directly by navigating to <a class="link" href="http://localhost:3000/my-plugin">http://localhost:3000/my-plugin</a>.
					</p></div><p>
					Insert screenshot
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						You can also serve the plugin in isolation by running yarn start in the plugin directory. Or by using the yarn workspace command, for example:
					</p><pre class="programlisting language-terminal">yarn workspace @backstage/plugin-my-plugin start # Also supports --check</pre></div></div></section></section><section class="section" id="proc-converting-a-custom-plugin-into-an-rhdh-dynamic-plugin_assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h3 class="title">1.4. Converting a custom plugin into a dynamic plugin</h3></div></div></div><section class="section" id="proc-example-custom-plugin-installation_assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h4 class="title">1.4.1. Example of installing a custom plugin in Red Hat Developer Hub</h4></div></div></div><p>
					This example demonstrates how to package and install dynamic plugins using the Backstage <span class="strong strong"><strong>Entity Feedback</strong></span> community plugin that is not included in Red Hat Developer Hub pre-installed dynamic plugins.
				</p><div class="itemizedlist"><p class="title"><strong>Limitations</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							You need to ensure that your custom plugin is built with a compatible version of Backstage. In Developer Hub, click <span class="strong strong"><strong>Settings</strong></span>. Your custom plugin must be compatible with the <span class="strong strong"><strong>Backstage Version</strong></span> (or the closest previous version) that is displayed in the <span class="strong strong"><strong>Metadata</strong></span> section of Red Hat Developer Hub.
						</p><p class="simpara">
							For example, if you view the <a class="link" href="https://github.com/backstage/community-plugins/commits/main/workspaces/entity-feedback/backstage.json">history</a> of the <code class="literal">backstage.json</code> file for the <span class="strong strong"><strong>Entity Feedback</strong></span> plugin, the <code class="literal">1fc87de</code> commit is closest previous version to Backstage version of 1.39.1.
						</p><div class="figure" id="idm46550815765920"><p class="title"><strong>Figure 1. <code class="literal">backstage.json</code> file history in Github</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/rhdh/custom-limitations.png" alt="custom limitations"/></div></div></div></li></ul></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Your local environment meets the following requirements:
						</li><li class="listitem">
							<span class="strong strong"><strong>Node.js:</strong></span> Version 22.x
						</li><li class="listitem">
							<span class="strong strong"><strong>Yarn:</strong></span> Version 4.x
						</li><li class="listitem">
							<span class="strong strong"><strong>git CLI</strong></span>
						</li><li class="listitem">
							<span class="strong strong"><strong>jq CLI:</strong></span> Command-line JSON processor
						</li><li class="listitem">
							<span class="strong strong"><strong>OpenShift CLI (oc):</strong></span> The client for interacting with your OpenShift cluster.
						</li><li class="listitem">
							<span class="strong strong"><strong>Container runtime:</strong></span> Either podman or docker is required for packaging the plugin into an OCI image and logging into registries.
						</li><li class="listitem">
							<span class="strong strong"><strong>Container registry access:</strong></span> Access to an OCI-compliant container registry (such as the internal OpenShift registry or a public registry like Quay.io).
						</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Clone the source code for the <span class="strong strong"><strong>Entity Feedback</strong></span> plugin, as follows:
						</p><pre class="programlisting language-terminal">$ git clone https://github.com/backstage/community-plugins.git
$ cd community-plugins</pre></li><li class="listitem"><p class="simpara">
							Prepare your environment to build the plugin by enabling Yarn for your Node.js installation, as follows:
						</p><pre class="programlisting language-terminal">$ corepack enable yarn</pre></li><li class="listitem"><p class="simpara">
							Install the dependencies, compile the code, and build the plugins, as follows:
						</p><pre class="programlisting language-terminal">$ cd workspaces/entity-feedback
$ yarn install
$ yarn tsc
$ yarn build:all</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								After this step, with upstream Backstage, you publish the built plugins to a NPM or NPM-compatible registry. In this example, as you are building this plugin to support it being loaded dynamically by Red Hat Developer Hub, you can skip the <code class="literal">npm publish</code> step that publishes the plugin to a NPM registry. Instead, you can package the plugin for dynamic loading and publish it as a container image on <code class="literal">Quay.io</code> or your preferred container registry.
							</p></div></div></li><li class="listitem"><p class="simpara">
							Prepare the <span class="strong strong"><strong>Entity Feedback</strong></span> frontend plugin by using the Red Hat Developer Hub CLI. The following command uses the plugin files in the <code class="literal">dist</code> folder that was generated by the <code class="literal">yarn build:all</code> command, and creates a new <code class="literal">dist-scalprum</code> folder that contains the necessary configuration and source files to enable dynamic loading:
						</p><pre class="programlisting language-terminal">$ cd plugins/entity-feedback
$ npx @red-hat-developer-hub/cli@latest plugin export</pre><p class="simpara">
							When this command packages a frontend plugin, it uses a default Scalprum configuration if one is not found. The Scalprum configuration is used to specify the plugin entry point and exports, and then to build a <code class="literal">dist-scalprum</code> folder that contains the dynamic plugin. The default Scalprum configuration is shown below, however a <code class="literal">scalprum</code> key can be added to the <code class="literal">package.json</code> file used by your plugin to set custom values, if necessary:
						</p><pre class="programlisting language-json">{
  "name": "backstage-community.plugin-entity-feedback",
  "exposedModules": {
    "PluginRoot": "./src/index.ts"
  }
}</pre><p class="simpara">
							The following <code class="literal">plugin-manifest.json</code> file, which Red Hat Developer Hub uses to load the plugin, is located in the <code class="literal">dist-dynamic/dist-scalprum</code> folder:
						</p><pre class="programlisting language-json">{
  "name": "backstage-community.plugin-entity-feedback",
  "version": "0.6.0",
  "extensions": [],
  "registrationMethod": "callback",
  "baseURL": "auto",
  "loadScripts": [
    "backstage-community.plugin-entity-feedback.fd691533c03cb52c30ac.js"
  ],
  "buildHash": "fd691533c03cb52c30acbb5a80197c9d"
}</pre></li><li class="listitem"><p class="simpara">
							Package the plugin into a container image and publish it to Quay.io or your preferred container registry:
						</p><pre class="programlisting language-terminal">$ export QUAY_USER=replace-with-your-username
$ export PLUGIN_NAME=entity-feedback-plugin
$ export VERSION=$(cat package.json | jq .version -r)

$ npx @red-hat-developer-hub/cli@latest plugin package \
  --tag quay.io/$QUAY_USER/$PLUGIN_NAME:$VERSION

$ podman login quay.io
$ podman push quay.io/$QUAY_USER/$PLUGIN_NAME:$VERSION</pre></li><li class="listitem"><p class="simpara">
							Repeat the same steps for the backend plugin. Scalprum is not required for backend plugins, and a <code class="literal">dist-dynamic</code> folder is generated instead of a <code class="literal">dist-scalprum</code> folder:
						</p><pre class="programlisting language-terminal">$ cd ../entity-feedback-backend/
$ npx @red-hat-developer-hub/cli@latest plugin export

$ export QUAY_USER=replace-with-your-username
$ export PLUGIN_NAME=entity-feedback-plugin-backend
$ export VERSION=$(cat package.json | jq .version -r)

$ npx @red-hat-developer-hub/cli@latest plugin package \
  --tag quay.io/$QUAY_USER/$PLUGIN_NAME:$VERSION

$ podman push quay.io/$QUAY_USER/$PLUGIN_NAME:$VERSION</pre><p class="simpara">
							Those commands result in two container images being published to your container registry.
						</p><div class="figure" id="idm46550808485072"><p class="title"><strong>Figure 2. Container images published to Quay.io</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/rhdh/custom-container-images.png" alt="custom container images"/></div></div></div></li></ol></div></section></section><section class="section" id="convert-a-custom-plugin-to-a-dynamic-plugin-by-using-the-plugin-factory"><div class="titlepage"><div><div><h3 class="title">1.5. Convert a custom plugin to a dynamic plugin by using the Plugin Factory</h3></div></div></div><p>
				The RHDH Plugin Factory automates the process of converting Backstage plugins into RHDH dynamic plugins.
			</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					The RHDH Plugin Factory is developer preview…​
				</p></div></div><p>
				The RHDH Plugin Factory automates the process of converting Backstage plugins into RHDH dynamic plugins. It provides:
			</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Source Repository Management</span></dt><dd>
							Clone and checkout plugin source repositories
						</dd><dt><span class="term">Patch &amp; Overlay System</span></dt><dd>
							Apply custom modifications to plugin source code before exporting
						</dd><dt><span class="term">Dependency Management</span></dt><dd>
							Automated yarn installation with TypeScript compilation.
						</dd><dt><span class="term">Dynamic Plugin Packaging</span></dt><dd>
							Build, export and package plugins using the RHDH CLI
						</dd><dt><span class="term">Container Image Publishing</span></dt><dd>
							Optionally push to container registries (Quay, OpenShift, etc.)
						</dd></dl></div><p>
				The Dynamic Plug-in Factory is an experimental Developer Preview tool from the Red Hat team that shifts the plug-in build process from an imperative approach to a declarative one. Instead of running a sequence of commands, you define build parameters with configuration files.
			</p><p>
				The plug-in factory reduces the complexity of the build process by encapsulating many of the developer tools within a container image. When you feed it a configuration, it produces ready-to-deploy plug-in artifacts. This ensures plug-ins are built in a clean, reproducible environment every time, regardless of what version of the Backstage dependencies you have in your local development or continuous integration (CI) environments.
			</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
						You must install a container engine, for example, Podman or Docker in your environment.
					</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
						After you install a container engine, pull the Developer Hub compatible version of the dynamic plugin factory image. podman pull quay.io/rhdh-community/dynamic-plugins-factory:1.8
					</li><li class="listitem"><p class="simpara">
						To define the source, create a folder, for example my-plugins ,that contains a config subfolder, and create a .gitignore to avoid committing any secrets.
					</p><pre class="programlisting language-terminal">mkdir -p my-plugins/config
cd my-plugins
echo ".env" &gt;&gt; .gitignore</pre><p class="simpara">
						[INFO] The source.json only accepts a single repo. You can build multiple workspaces from a single repository. To build plug-ins from different repositories (e.g., the Backstage Community plug-ins repository and a private internal repository), you will need to create separate config folders for each upstream and run the factory for each config. 
					</p></li><li class="listitem"><p class="simpara">
						To specify target plugins, create a plugins-list.yaml to specify exactly which packages should be built and published as dynamic plug-ins:
					</p><pre class="programlisting language-terminal">plugins/entity-feedback:
plugins/entity-feedback-backend: --embed-package @backstage/plugin-notifications-node --embed-package @backstage/plugin-notifications-common</pre></li></ol></div><p>
				In the manual method, you had to run podman login and podman push for every plug-in. The factory automates this process. Create a .env file in the config directory. This file tells the factory where to push the resulting container images.
			</p><p>
				+
			</p><pre class="programlisting language-terminal"># Registry Configuration
REGISTRY_URL=quay.io
REGISTRY_NAMESPACE=your-namespace # usually this is your username or org name
REGISTRY_USERNAME=your-quay-or-robot-username
REGISTRY_PASSWORD=your-quay-or-robot-password</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					I’m using a robot account with specific write permissions instead of passing my Quay username and password directly to the factory container. Other container registries support similar capabilities. Using a robot account is optional, but recommended when build systems will access Quay.io on your behalf. 
				</p></div></div><div class="formalpara"><p class="title"><strong>Run the factory</strong></p><p>
					This is where automation takes over. No need to run yarn install or tsc. Simply run the factory container, mounting the config directory and specifying the target workspace. Note that we are adding the --push-images flag to tell the factory to push the images to the container registry specified in the .env configuration
				</p></div><p>
				+
			</p><pre class="programlisting language-terminal">podman run --rm -it \
  --device /dev/fuse \
  -v ./config:/config \
  quay.io/rhdh-community/dynamic-plugins-factory:1.8 \
  --push-images \
  --workspace-path=workspaces/entity-feedback</pre><p>
				+ The container will: * Clone the repository defined in source.json. * Install all necessary dependencies in an isolated environment. * Build the plug-ins listed in plugins-list.yaml. * Package them and automatically push them to Quay.io.
			</p><p>
				Once the build is complete, make sure that the new container image repositories are public to avoid the need to configure pull secrets to follow this article. Figure 4 shows where the repository visibility setting is located in Quay.io. 
			</p><div class="formalpara"><p class="title"><strong>Add the plug-ins to Developer Hub</strong></p><p>
					Once the factory has successfully pushed your images to Quay.io, the process for adding them to your Red Hat Developer Hub instance is identical to the manual method. You will need to update your dynamic-plugins.yaml configuration to point to the new OCI images you just created. plugins:
				</p></div><pre class="programlisting language-yaml">  - package: oci://quay.io/evanshortiss/backstage-community-plugin-entity-feedback:0.9.0!backstage-community-plugin-entity-feedback
    disabled: false
    pluginConfig:
      dynamicPlugins:
        frontend:
          backstage-community.plugin-entity-feedback:
            entityTabs:
              - mountPoint: entity.page.feedback
                path: /feedback
                title: Feedback
            mountPoints:
              - config:
                  layout:
                    gridColumn: 1 / -1
                importName: StarredRatingButtons
                mountPoint: entity.page.feedback/cards
              - config:
                  layout:
                    gridColumn: 1 / -1
                importName: EntityFeedbackResponseContent
                mountPoint: entity.page.feedback/cards
  - package: oci://quay.io/evanshortiss/backstage-community-plugin-entity-feedback-backend:0.11.0!backstage-community-plugin-entity-feedback-backend
    disabled: false</pre><div class="formalpara"><p class="title"><strong>Verification</strong></p><p>
					Once the plug-ins are added to your configuration, restart Developer Hub and confirm they’ve been installed by viewing the container logs and viewing the Installed packages section in the Admin &gt; Extensions view, as shown in Figure 5. If you are a plug-in developer, you may prefer your own process. If you are a platform engineer tasked with curating a catalog of many different open-source plug-ins for your internal developer portal, the Dynamic Plugin Factory offers a cleaner, more scalable way to manage your supply chain.
				</p></div></section><section class="section" id="con-testing-with-rhdh-local_assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h3 class="title">1.6. Verify plugins locally</h3></div></div></div><p>
				RHDH Local excels at supporting local plugin development, enabling you to build, test, and iterate on dynamic plugins <span class="strong strong"><strong>before</strong></span> publishing them to a registry. This guide covers the complete development workflow from scaffolding to testing.
			</p><section class="section" id="load-dynamic-plugins-from-a-local-directory"><div class="titlepage"><div><div><h4 class="title">1.6.1. Load dynamic plugins from a local directory</h4></div></div></div><p>
					During boot, the install-dynamic-plugins container reads the contents of the plugin configuration file and activates, configures, or downloads any plugins listed. RHDH Local supports two ways of specifying dynamic plugin configuration:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Default path: configs/dynamic-plugins/dynamic-plugins.yaml
						</li><li class="listitem">
							User override path: configs/dynamic-plugins/dynamic-plugins.override.yaml or configs/dynamic-plugins.yaml. If present, this file will automatically override the default and be used by the install-dynamic-plugins container. configs/dynamic-plugins/dynamic-plugins.override.yaml takes precedence over configs/dynamic-plugins.yaml.
						</li></ol></div><p>
					In addition, the local-plugins directory is mounted into the install-dynamic-plugins container at /opt/app-root/src/local-plugins. Any plugins placed there can be activated/configured the same way (without downloading).
				</p><p>
					To load dynamic plugins from your local machine:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Copy the dynamic plugin binary file into the local-plugins directory.
						</li><li class="listitem">
							Make sure permissions allow the container to read the files (e.g. chmod -R 777 local-plugins for quick testing).
						</li><li class="listitem"><p class="simpara">
							Configure your plugin in one of the supported config files:
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Prefer configs/dynamic-plugins/dynamic-plugins.override.yaml for local user overrides.
								</li><li class="listitem">
									If no override file is present, configs/dynamic-plugins/dynamic-plugins.yaml will be used.
								</li></ol></div></li><li class="listitem">
							See <a class="link" href="https://github.com/redhat-developer/rhdh-local/blob/main/docs/rhdh-local-guide/configuration.md">Configuration</a> for more information about updating and reloading configurations.
						</li></ol></div></section></section><section class="section" id="proc-packaging-and-publishing-artifacts_assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h3 class="title">1.7. Packaging and publishing artifacts</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Open Container Initiative (OCI) image (recommended)
					</li><li class="listitem">
						TGZ file
					</li><li class="listitem"><p class="simpara">
						JavaScript package
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							Exported dynamic plugin packages must only be published to private NPM registries.
						</p></div></div></li></ul></div><section class="section" id="proc-create-plugin-oci-image_assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h4 class="title">1.7.1. Creating an OCI image with dynamic packages</h4></div></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							You have installed <code class="literal">podman</code> or <code class="literal">docker</code>.
						</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Navigate to the plugin’s root directory (not the <code class="literal">dist-dynamic</code> directory).
						</li><li class="listitem"><p class="simpara">
							Run the following command to package the plugin into an OCI image:
						</p><div class="formalpara"><p class="title"><strong>Example command to package an exported custom plugin</strong></p><p>
								
<pre class="programlisting language-terminal">$ npx @red-hat-developer-hub/cli@latest plugin package --tag quay.io/example/image:v0.0.1</pre>
							</p></div><p class="simpara">
							In the previous command, the <code class="literal">--tag</code> argument specifies the image name and tag.
						</p></li><li class="listitem"><p class="simpara">
							Run one of the following commands to push the image to a registry:
						</p><div class="formalpara"><p class="title"><strong>Example command to push an image to a registry using podman</strong></p><p>
								
<pre class="programlisting language-terminal">$ podman push quay.io/example/image:v0.0.1</pre>
							</p></div><div class="formalpara"><p class="title"><strong>Example command to push an image to a registry using docker</strong></p><p>
								
<pre class="programlisting language-terminal">$ docker push quay.io/example/image:v0.0.1</pre>
							</p></div><p class="simpara">
							The output of the <code class="literal">package-dynamic-plugins</code> command provides the plugin’s path for use in the <code class="literal">dynamic-plugin-config.yaml</code> file.
						</p></li></ol></div></section><section class="section" id="proc-create-plugin-tgz-file_assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h4 class="title">1.7.2. Creating a TGZ file with dynamic packages</h4></div></div></div><div class="formalpara"><p class="title"><strong>Prerequisites</strong></p><p>
						assembly-developing-and-deploying-plugins
					</p></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Navigate to the <code class="literal">dist-dynamic</code> directory.
						</li><li class="listitem"><p class="simpara">
							Run the following command to create a <code class="literal">tgz</code> archive:
						</p><div class="formalpara"><p class="title"><strong>Example command to create a <code class="literal">tgz</code> archive</strong></p><p>
								
<pre class="programlisting language-terminal">$ npm pack</pre>
							</p></div><p class="simpara">
							You can obtain the integrity hash from the output of the <code class="literal">npm pack</code> command by using the <code class="literal">--json</code> flag as follows:
						</p><div class="formalpara"><p class="title"><strong>Example command to obtain the integrity hash of a <code class="literal">tgz</code> archive</strong></p><p>
								
<pre class="programlisting language-terminal">$ npm pack --json | head -n 10</pre>
							</p></div></li><li class="listitem"><p class="simpara">
							Host the archive on a web server accessible to your RHDH instance, and reference its URL in the <code class="literal">dynamic-plugin-config.yaml</code> file as follows:
						</p><div class="formalpara"><p class="title"><strong>Example <code class="literal">dynamic-plugin-config.yaml</code> file</strong></p><p>
								
<pre class="programlisting language-yaml">plugins:
  - package: https://example.com/backstage-plugin-myplugin-1.0.0.tgz
    integrity: sha512-&lt;hash&gt;</pre>
							</p></div></li><li class="listitem"><p class="simpara">
							Run the following command to package the plugins:
						</p><div class="formalpara"><p class="title"><strong>Example command to package a dynamic plugin</strong></p><p>
								
<pre class="programlisting language-terminal">$ npm pack --pack-destination ~/test/dynamic-plugins-root/</pre>
							</p></div><div class="admonition tip"><div class="admonition_header">Tip</div><div><p>
							To create a plugin registry using HTTP server on OpenShift Container Platform, run the following commands:
						</p><div class="formalpara"><p class="title"><strong>Example commands to build and deploy an HTTP server in OpenShift Container Platform</strong></p><p>
								
<pre class="programlisting language-terminal">$ oc project my-rhdh-project
$ oc new-build httpd --name=plugin-registry --binary
$ oc start-build plugin-registry --from-dir=dynamic-plugins-root --wait
$ oc new-app --image-stream=plugin-registry</pre>
							</p></div></div></div></li><li class="listitem"><p class="simpara">
							Configure your RHDH to use plugins from the HTTP server by editing the <code class="literal">dynamic-plugin-config.yaml</code> file:
						</p><div class="formalpara"><p class="title"><strong>Example configuration to use packaged plugins in RHDH</strong></p><p>
								
<pre class="programlisting language-yaml">plugins:
  - package: http://plugin-registry:8080/backstage-plugin-myplugin-1.9.6.tgz</pre>
							</p></div></li></ol></div></section><section class="section" id="proc-create-plugin-js-package_assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h4 class="title">1.7.3. Creating a JavaScript package with dynamic packages</h4></div></div></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						The derived dynamic plugin JavaScript packages must not be published to the public NPM registry. If you must publish to the NPM registry, use a private registry.
					</p></div></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Navigate to the <code class="literal">dist-dynamic</code> directory.
						</li><li class="listitem"><p class="simpara">
							Run the following command to publish the package to your private NPM registry:
						</p><div class="formalpara"><p class="title"><strong>Example command to publish a plugin package to an NPM registry</strong></p><p>
								
<pre class="programlisting language-terminal">$ npm publish --registry &lt;npm_registry_url&gt;</pre>
							</p></div><div class="admonition tip"><div class="admonition_header">Tip</div><div><p>
							You can add the following to your <code class="literal">package.json</code> file before running the <code class="literal">export</code> command:
						</p><div class="formalpara"><p class="title"><strong>Example <code class="literal">package.json</code> file</strong></p><p>
								
<pre class="programlisting language-json">{
  "publishConfig": {
    "registry": "&lt;npm_registry_url&gt;"
  }
}</pre>
							</p></div><p>
							If you modify <code class="literal">publishConfig</code> after exporting the dynamic plugin, re-run the <code class="literal">plugin export</code> command to ensure the correct configuration is included.
						</p></div></div></li></ol></div></section></section><section class="section" id="proc-deployment-configurations_assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h3 class="title">1.8. Deployment configurations</h3></div></div></div></section><section class="section" id="ref-best-practices-and-reference_assembly-developing-and-deploying-plugins"><div class="titlepage"><div><div><h3 class="title">1.9. Maintain and scale plugins to ensure long-term stability</h3></div></div></div></section></section><div><div xml:lang="en-US" class="legalnotice" id="idm46550792890128"><h1 class="legalnotice">Legal Notice</h1><div class="para">
		Copyright <span class="trademark"/>© 2026 Red Hat, Inc.
	</div><div class="para">
		The text of and illustrations in this document are licensed by Red Hat under a Creative Commons Attribution–Share Alike 3.0 Unported license ("CC-BY-SA"). An explanation of CC-BY-SA is available at <a class="uri" href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a>. In accordance with CC-BY-SA, if you distribute this document or an adaptation of it, you must provide the URL for the original version.
	</div><div class="para">
		Red Hat, as the licensor of this document, waives the right to enforce, and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent permitted by applicable law.
	</div><div class="para">
		Red Hat, Red Hat Enterprise Linux, the Shadowman logo, the Red Hat logo, JBoss, OpenShift, Fedora, the Infinity logo, and RHCE are trademarks of Red Hat, Inc., registered in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Linux</span>® is the registered trademark of Linus Torvalds in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Java</span>® is a registered trademark of Oracle and/or its affiliates.
	</div><div class="para">
		<span class="trademark">XFS</span>® is a trademark of Silicon Graphics International Corp. or its subsidiaries in the United States and/or other countries.
	</div><div class="para">
		<span class="trademark">MySQL</span>® is a registered trademark of MySQL AB in the United States, the European Union and other countries.
	</div><div class="para">
		<span class="trademark">Node.js</span>® is an official trademark of Joyent. Red Hat is not formally related to or endorsed by the official Joyent Node.js open source or commercial project.
	</div><div class="para">
		The <span class="trademark">OpenStack</span>® Word Mark and OpenStack logo are either registered trademarks/service marks or trademarks/service marks of the OpenStack Foundation, in the United States and other countries and are used with the OpenStack Foundation's permission. We are not affiliated with, endorsed or sponsored by the OpenStack Foundation, or the OpenStack community.
	</div><div class="para">
		All other trademarks are the property of their respective owners.
	</div></div></div></section></div></div><script type="text/javascript">
                        jQuery(document).ready(function() {
                            initSwitchery();
                            jQuery('pre[class*="language-"]').each(function(i, block){hljs.highlightBlock(block);});
                        });
                    </script></body></html>